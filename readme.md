# Empty CPP Example
This example project shows an empty configuration that can be used as a starting point to add components and functionality.{
  "readme_content": {
    "filename": "README.md",
    "content": "# Real-Time Flame Detection using MLX90640 and EFR32MG24\n\nThis project implements a real-time flame detection system using a SparkFun MLX90640 thermal infrared sensor array and a Silicon Labs EFR32MG24 microcontroller. It utilizes TensorFlow Lite for Microcontrollers (TFLM) to run a lightweight machine learning model directly on the embedded device for low-latency detection.\n\n## Overview\n\nThe system works as follows:\n1.  **Data Acquisition:** A dedicated firmware (`firmware/data_acquisition`) running on the EFR32MG24 reads raw thermal frames (32x24 pixels) from the MLX90640 sensor via I2C and streams the data over the serial (USB VCOM) port.\n2.  **Data Collection (Host PC):** A Python script (`training/collect_flame_data.py`) captures the streamed serial data and saves it into labeled CSV files (`data/flame.csv`, `data/noflame.csv`).\n3.  **Model Training (Host PC):** Another Python script (`training/create_flame_tinyml.py`) loads the CSV data, trains a simple Keras neural network, converts the trained model to TensorFlow Lite (Float32 format), and exports it as a C array (`.cc` and `.h` files).\n4.  **Inference (EFR32MG24):** The main inference firmware (`firmware/flame_detector`) runs on the EFR32MG24. It includes the TFLM library and the exported C model. It continuously reads frames from the MLX90640, preprocesses the data (normalization), feeds it into the TFLM interpreter, and prints the classification result (Flame Detected / No Flame Detected) along with the confidence score to the serial console.\n\n## Hardware Requirements\n\n*   **Microcontroller Board:** Silicon Labs EFR32MG24 Dev Kit (BRD2601B Rev A01 or similar EFR32xG24 board)\n*   **Thermal Sensor:** SparkFun MLX90640 Thermal IR Array (SEN-14843 or equivalent MLX90640 breakout board)\n*   **Connection:** Jumper wires for I2C connection (VCC, GND, SDA, SCL)\n*   **Interface:** USB Cable (Type A to Micro-B or Type C, depending on the Dev Kit) for programming, power, and serial communication.\n\n## Software Requirements\n\n*   **Host PC:** Windows, macOS, or Linux\n*   **IDE:** [Simplicity Studio v5](https://www.silabs.com/developers/simplicity-studio)\n*   **SDK:** Gecko SDK Suite v4.4.2 (or compatible, installable via Simplicity Studio) with EFR32MG24 support.\n*   **Python:** Python 3.x (tested with 3.8+)\n*   **Python Libraries:** Install using pip:\n    ```bash\n    pip install numpy pandas tensorflow scikit-learn pyserial\n    # Consider creating a requirements.txt: pip freeze > requirements.txt\n    ```\n*   **Serial Terminal:** A program to view serial output (e.g., Tera Term, PuTTY, screen, Simplicity Studio Serial Console).\n\n## Repository Structure\n\n```\n.\n├── data/                 # Contains collected CSV data (Example data might be included)\n│   ├── flame.csv\n│   └── noflame.csv\n├── firmware/\n│   ├── data_acquisition/ # Simplicity Studio project for streaming raw data (app.c)\n│   └── flame_detector/   # Simplicity Studio project for TFLM inference (app.cpp)\n│       └── model/        # Generated TFLite model C files\n│           ├── flame_detector_float_model.cc\n│           └── flame_detector_float_model.h\n├── training/             # Python scripts\n│   ├── collect_flame_data.py  # Script to collect data from serial port\n│   ├── create_flame_tinyml.py # Script to train model and generate C array\n│   └── requirements.txt  # (Optional) Python dependencies list\n├── .gitignore            # Git ignore file for Simplicity Studio/Python projects\n└── README.md             # This file\n```\n\n## Setup and Usage\n\n### 1. Hardware Connection\n\nConnect the MLX90640 sensor to the EFR32 Dev Kit using the I2C interface. Refer to the pinout diagrams for your specific board (BRD2601B) and sensor breakout.\n*   Sensor VCC -> Board 3.3V\n*   Sensor GND -> Board GND\n*   Sensor SDA -> Board I2C SDA pin (Check board schematic / configurator - e.g., PC04 on BRD2601B for I2C0)\n*   Sensor SCL -> Board I2C SCL pin (Check board schematic / configurator - e.g., PC05 on BRD2601B for I2C0)\n*   Connect the EFR32 Dev Kit to your PC via USB.\n\n### 2. Data Collection (Optional - Use provided data or collect your own)\n\n*   Open the `firmware/data_acquisition/` project in Simplicity Studio.\n*   Build and flash the firmware to the EFR32 board (Debug As -> Silicon Labs ARM Program).\n*   Identify the serial (VCOM) port assigned to the EFR32 on your PC.\n*   Run the `training/collect_flame_data.py` script:\n    ```bash\n    cd training\n    python collect_flame_data.py\n    ```\n*   Follow the script's prompts to select the serial port, baud rate (usually 115200), and record frames for both 'flame' and 'no-flame' scenarios. Ensure the CSV files are saved in the `data/` directory.\n\n### 3. Model Training (Optional - Use provided model or train your own)\n\n*   Ensure `flame.csv` and `noflame.csv` are present in the `data/` directory.\n*   Run the `training/create_flame_tinyml.py` script:\n    ```bash\n    cd training\n    python create_flame_tinyml.py\n    ```\n*   This will train the model and generate `flame_detector_float.tflite`, `flame_detector_float_model.cc`, and `flame_detector_float_model.h` (likely in a subfolder like `output_model/`).\n*   Copy the generated `.cc` and `.h` files into the `firmware/flame_detector/model/` directory, overwriting existing files if necessary.\n\n### 4. Build and Flash Inference Firmware\n\n*   Open the `firmware/flame_detector/` project in Simplicity Studio.\n*   Verify the project configuration (`.slcp` file) includes all necessary components (TFLM, I2CSPM, Sleep Timer, IO Stream USART VCOM, C++ Support, etc.).\n*   Ensure the model files (`model/flame_detector_float_model.cc` and `.h`) are included in the project build.\n*   Build the project (Hammer icon or Project -> Build Project).\n*   Flash the firmware to the EFR32 board (Debug icon or Debug As -> Silicon Labs ARM Program).\n\n### 5. Run and Monitor\n\n*   If you started a debug session, press Resume (F8 or Play icon). If you only flashed, reset the board or power cycle it.\n*   Open a serial terminal program (Tera Term, PuTTY, Simplicity Studio Terminal).\n*   Connect to the EFR32's VCOM port with settings: **115200 baud, 8 data bits, no parity, 1 stop bit (8N1)**.\n*   You should see initialization messages followed by periodic output indicating whether a flame is detected:\n    ```\n    >>> No Flame Detected (Confidence: 0.04)\n    ---\n    >>> No Flame Detected (Confidence: 0.02)\n    ---\n    ```\n*   Introduce a flame (e.g., lighter, candle) into the sensor's field of view. The output should change:\n    ```\n    >>> Flame Detected! (Confidence: 0.98)\n    ---\n    ```\n\n## Troubleshooting\n\n*   **No Serial Output:** Check COM port, baud rate (115200), cable connection. Ensure IO Stream USART (VCOM) is configured correctly in the `.slcp` file.\n*   **Sensor Errors:** Double-check I2C wiring (SDA/SCL swap is common). Verify the I2C pins configured in the I2CSPM component match the hardware connections.\n*   **TFLM Errors (Allocation/Ops):** Increase `TENSOR_ARENA_SIZE` in `app.cpp` if you get allocation errors. Ensure all required ops (e.g., `AddFullyConnected`, `AddLogistic`) are added in `init_ml_model` in `app.cpp`.\n*   **Build Errors:** Ensure all required SDK components are installed and included. Check that model files are correctly located and part of the build.\n\n## License\n\n*(Optional: Add your chosen license here, e.g., MIT, Apache 2.0. You should also add a LICENSE file to the repository.)*\n\nThis project is licensed under the [NAME OF LICENSE] License - see the LICENSE file for details.\n\n## Acknowledgments\n\n*(Optional: Mention any libraries, code snippets, or tutorials that were helpful.)*\n*   Melexis for the MLX90640 sensor.\n*   Silicon Labs for the EFR32MG24 and Simplicity Studio.\n*   The TensorFlow Lite Micro team.\n"
  }
}
